



1.GIL: Globle Interpreter Lock 全局解释器锁。GIL确保在同一时刻只能由1个线程进入解释器（看起来Python只能利用一个CPU核，甚至就几乎等于
       Python是个单线程的程序，），但是其保证了多份缓存之间的数据同步和线程间数据一致性。

    Python中有多个解释器（PyPy，Psyco, JPython等），同样一段代码可以通过CPython，PyPy，Psyco等不同的Python执行环境来执行，
但是Cpython是全球通用的解释器，所以只有Cpython中存在GIL。


2.GIL存在的原因：

    为了更有效的利用多核处理器的性能，就出现了多线程的编程方式，而随之带来的问题：就是线程间数据一致性和状态同步的困难。即使在CPU内部的Cache
也不例外，为了有效解决多份缓存之间的数据同步时各厂商花费了不少心思，也不可避免的带来了一定的性能损失。为了利用多核，Python开始支持多线程。
而解决多线程之间数据完整性和状态同步的最简单方法自然就是加锁。 于是有了GIL这把超级大锁，而当越来越多的代码库开发者接受了这种设定后，
他们开始大量依赖这种特性（即默认python内部对象是thread - safe的，无需在实现时考虑额外的内存锁和同步操作）。


3.当前GIL设计的缺陷：基于pcode数量的调度方式

    按照Python社区的想法，操作系统本身的线程调度已经非常成熟稳定了，没有必要自己搞一套。所以Python的线程就是C语言的一个pthread，并通过操作系统
 调度算法进行调度（例如linux是CFS）。为了让各个线程能够平均利用CPU时间，python会计算当前已执行的微代码数量，达到一定阈值后就强制释放GIL。
 而这时也会触发一次操作系统的线程调度（当然是否真正进行上下文切换由操作系统自主决定）。

伪代码

while True:
    acquire GIL
    for i in 1000:
        do something
    release GIL
    /* Give Operating System a chance to do thread scheduling */

   这种模式在只有一个CPU核心的情况下毫无问题。任何一个线程被唤起时都能成功获得到GIL（因为只有释放了GIL才会引发线程调度）。
但当CPU有多个核心的时候，问题就来了。从伪代码可以看到，从release GIL到acquire GIL之间几乎是没有间隙的。所以当其他在其他核心上的线程被唤醒时，
大部分情况下主线程已经又再一次获取到GIL了。这个时候被唤醒执行的线程只能白白的浪费CPU时间，看着另一个线程拿着GIL欢快的执行着。
然后达到切换时间后进入待调度状态，再被唤醒，再等待，以此往复恶性循环。

PS：当然这种实现方式是原始而丑陋的，Python的每个版本中也在逐渐改进GIL和线程调度之间的互动关系。例如先尝试持有GIL在做线程上下文切换，
    在IO等待时释放GIL等尝试。但是无法改变的是GIL的存在使得操作系统线程调度的这个本来就昂贵的操作变得更奢侈了。


4.结论：

    1.GIL的存在，让PythonGIL无疑就是一把全局排他锁。毫无疑问全局锁的存在会对多线程的效率有不小影响。甚至就几乎等于Python只能操作单线程！！！
      可以用多进程和协程、多线程的代码用其他语言写来解决。

    2.只有IO Bound场景下得多线程会得到较好的性能。Python的多线程在多核CPU上，只对于IO密集型计算产生正面效果；
      而当有至少有一个CPU密集型线程存在，那么多线程效率会由于GIL而大幅下降。

    3.GIL在较长一段时间内将会继续存在，但是会不断对其进行改进，因为从Python3.5到3.7已经对多线程优化了很多，串行和多线程并发的差距在逐渐缩小。